<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>three.js app</title>
		<style>
			body {
			margin: 0;
			padding: 0;
			overflow: hidden;
			}

			.container {
			width: 100%;
			height: 100%;
			}
		</style>
	</head>
	<body>
		<div class="container"></div>
		<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
		<script type="module">

			// Create a Three.js scene and camera
			var scene = new THREE.Scene();
			import { OrbitControls } from './js/OrbitControls.js';	
			
			// Create a Three.js renderer
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.PCFSoftShadowMap;
			document.body.appendChild( renderer.domElement );

			var camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
			
			var minZoom = 2; // set the minimum zoom distance
			var maxZoom = 10; // set the maximum zoom distance
			var zoomSpeed = 0.5; // set the speed of the zoom
			let isMouseDown = false;
			var mouseCoords = { x: 0, y: 0 };
			var model;
			let mixer;

			const clock = new THREE.Clock();
			const container = document.getElementById( 'container' );
			
			camera.position.set(0, 1, 5);

			// Load the glTF model using the GLTFLoader
			var loader = new THREE.GLTFLoader();
			var pointLight = new THREE.PointLight(0xefd1b5, 1, 100);
			pointLight.position.set(0, 5, 5); // set the position of the light
			pointLight.castShadow = true; // default false
			scene.add(pointLight);

			//Set up shadow properties for the light
			pointLight.shadow.mapSize.width = 512; // default
			pointLight.shadow.mapSize.height = 512; // default
			pointLight.shadow.camera.near = 0.5; // default
			pointLight.shadow.camera.far = 500; // default

			loader.load( 'models/scene.gltf', function ( gltf ) {
			model = gltf.scene;
			model.position.set( 1, 1, 0 );
			model.scale.set( 0.01, 0.01, 0.01 );
			model.castShadow = true; //default is false
			model.receiveShadow = true; //default
			scene.add( model );

			mixer = new THREE.AnimationMixer( model );
			mixer.clipAction( gltf.animations[ 0 ] ).play();
			
			animate();
			
			}, undefined, function (error) {
			console.error( error );
			} );

			window.onresize = function () {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			};

			// Animate the scene
			function animate() {
				requestAnimationFrame( animate );
				const delta = clock.getDelta();
				mixer.update( delta );
				renderer.render( scene, camera );
			}

			var onMouseDown = function (event) {
			mouseCoords.x = event.clientX;
			mouseCoords.y = event.clientY;
			document.addEventListener('mousemove', onMouseMove, false);
			document.addEventListener('mouseup', onMouseUp, false);
			};

			var onMouseMove = function (event) {
			var deltaX = event.clientX - mouseCoords.x;
			var deltaY = event.clientY - mouseCoords.y;

			model.rotation.y += deltaX * 0.01;
			model.rotation.x += deltaY * 0.01;

			mouseCoords.x = event.clientX;
			mouseCoords.y = event.clientY;
			};

			var onMouseUp = function () {
			document.removeEventListener('mousemove', onMouseMove, false);
			document.removeEventListener('mouseup', onMouseUp, false);
			};

			document.addEventListener('mousedown', onMouseDown, false);

			window.addEventListener('wheel', function(event) {
				var delta = event.wheelDelta ? event.wheelDelta : -event.deltaY;
    
				// Calculate the new camera position
				if (delta > 0 && camera.position.z > minZoom) {
					// Zoom in
					camera.position.z -= zoomSpeed;
				} else if (delta < 0 && camera.position.z < maxZoom) {
					// Zoom out
					camera.position.z += zoomSpeed;
				}
				
				// Update the camera
				camera.updateProjectionMatrix();
			});
		</script>
	</body>
</html>